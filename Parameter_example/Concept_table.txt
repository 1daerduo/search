import tkinter as tk
from tkinter import filedialog
import pandas as pd
import re
import json
import sys
import datetime
from collections import OrderedDict

# 创建窗口
root = tk.Tk()
root.withdraw()

# 选择日志文件
log_file_path = filedialog.askopenfilename(title='选择日志文件', filetypes=[('日志文件', '*.txt'),('日志文件', '*.log')])

# 选择规则文件，规则文件的中每个工作边又两列分别为：”规则“和”结果“
rules_file_path = filedialog.askopenfilename(title='选择规则文件', filetypes=[('Excel文件', '*.xlsx')])

#1.获取参数，存储到一个参数结构中。

#2.如果参数中有“a”或者“A”，调用#4的程序时候，使用的规则结构是所有工作表的规则，如果没有则提示使用者指定工作表，然后调用#4时使用指定的工作表的规则（即只匹配其中一个工作表）。

#3.打开规则文件，读取其内包括的所有工作表的名称，存储到一个规则结构中，并且结构按照规则表来区分。
	3.1然后创建一个全局json结构

#4.打开规则文件读取某一个工作表中的所有规则，存储到结构中；
	#4.1.json结构中添加以工作表为名的对象。{"工作名":{}}
	#4.1.打开日志文件（按照utf-8打开），读取一条规则结构的”规则“，用正则表达式在日志文件中查找规则。
	#4.2.每匹配到一次，就计数器count+=1，记录匹配到的行号，将行号与匹配行组合起来成新的文本，如果
		 count>0, 在接”工作表“对象中添加以”规则“为名的结构{"工作名":{”规则“:{}}}；
		 4.2.1.在”规则“结构中添加键值对，内容是：
		 "匹配项目":["行号 匹配行内容"，"行号 匹配行内容"],则json结构为{"工作名":{"规则":{}}；
		 4.2.2.在”规则“结构中添加键值对，内容是：
		 "次数":"count",则json结构为{"工作名":{"规则":{"匹配项目":["行号 匹配行内容","行号 匹配行内容"],"次数":"count"}}}；
		 4.2.3.在”规则“结构中添加键值对，内容是：
		 "结果":"规则列的结果",则json结构为{"工作名":{"规则":{"匹配项目":["行号 匹配行内容","行号 匹配行内容"],"次数":"count","结果":"规则列的结果"}}}；
		 4.2.4.循环匹配每一行规则。123
		 4.2.5.如果所有的规则都能在日志文件中找到，则在“工作名”结构中添加键值对，内容是：
		 "判定":"成功"，则json结构为{"工作名":{"规则":{"匹配项目":["行号 匹配行内容","行号 匹配行内容"],"次数":"count","结果":"规则列的结果"},"判定":"成功"}}
		   如果不是所有都匹配成功，则在“工作名”结构中添加键值对，内容是：
		 "判定":"失败"，则json结构为{"工作名":{"规则":{"匹配项目":["行号 匹配行内容","行号 匹配行内容"],"次数":"count","结果":"规则列的结果"},"判定":"失败"}}

#5.匹配工作完成
	#5.1 输出json文本
		#5.1.1 如果参数带着大小写“t”or“T”,则将json文件名 需要根据当前日期和时间命名
		#5.1.2 如果参数不带带着大小写“t”or“T”,则将json文件名 命名为“output.json”
		#5.1.2 输出json结构到json文件（utf-8）。
		
#6.如果输出的参数有“w”或者“W”,需要将这些json文本以方便查看的方式输出到windown窗口。 

#7.对于#4.2.5的匹配结果应该输出到CMD窗口，让运行者第一时间直到整个匹配的结果。